# 二叉树

## 二叉树种类

满二叉树：只有度为0和度为2的结点，并且度为0的结点在同一层上。

完全二叉树：定义为除了最后一层没有填满，每层节点数达到最大，且最后一层节点都集中在该层最左边若干位置。优先级队列其实是⼀个堆，堆就是⼀棵完全⼆叉树，同时保证⽗⼦节点的顺序关系。

**C++**中**map**、**set**、**multimap**，**multiset**的底层实现都是平衡⼆叉搜索树，所以map、set的增删操作时间时间复杂度是log n，注意我这⾥没有说unordered_map、unordered_set、unordered_map、unordered_map底层实现是哈希表。

二叉搜索树、平衡二叉树、平衡二叉搜索树

红⿊树就是⼀种⼆叉平衡搜索树，这两个树不是独⽴的，所以C++中map、multimap、set、multiset的底层实现机制是⼆叉平衡搜索树，再具体⼀点是红⿊树。

## 二叉树存储方式

二叉树可以链式存储也可以顺序存储。链式用指针，顺序用数组（广度优先遍历）。如果⽗节点的数组下表是**i**，那么它的左孩⼦就是i * 2 + 1，右孩⼦就是 i * 2 + 2。

## 二叉树遍历方式

两种主要遍历方式：深度优先遍历（包括前序、中序、后序遍历三种）：先往深走，遇到叶子节点往回走；广度优先遍历：一层层遍历。

深度优先遍历可以通过迭代和递归实现，而广度优先可以通过迭代来实现。二叉树的深度优先遍历的非递归的通用做法是采用栈，广度优先遍历的非递归的通用做法是采用队列。

深度优先遍历可以通过栈来实现递归的作用，而广度优先可以通过队列来实现。

morris遍历是⼆叉树遍历算法的超强进阶算法，morris遍历可以将⾮递归遍历中的空间复杂度降为O(1)，⽐较⼩众，⾯试⼏乎不会考。

## 二叉树题目

1、翻转二叉树：针对翻转⼆叉树，我给出了⼀种递归，三种迭代（两种模拟深度优先遍历，⼀种层序遍历）的写法，都是之前我们讲过的写法，融汇贯通⼀下⽽已。
